{
  "version": 3,
  "sources": ["../../vue-inline-svg/src/index.js", "dep:vue-inline-svg"],
  "sourcesContent": ["/** @type Object{string: Promise<Element>} */\nconst cache = {};\n\n/**\n * Remove false attrs\n * @param {Object} attrs\n */\nfunction filterAttrs(attrs) {\n    return Object.keys(attrs).reduce((result, key) => {\n        if (attrs[key] !== false && attrs[key] !== null && attrs[key] !== undefined) {\n            result[key] = attrs[key];\n        }\n        return result;\n    }, {});\n}\n\nconst InlineSvgComponent = {\n    name: 'InlineSvg',\n    inheritAttrs: false,\n    render(createElement) {\n        if (!this.svgElSource) {\n            return null;\n        }\n        return createElement(\n            'svg',\n            {\n                on: this.$listeners,\n                attrs: Object.assign(this.getSvgAttrs(this.svgElSource), filterAttrs(this.$attrs)),\n                domProps: {\n                    innerHTML: this.getSvgContent(this.svgElSource),\n                },\n            },\n        );\n    },\n    props: {\n        src: {\n            type: String,\n            required: true,\n        },\n        title: {\n            type: String,\n        },\n        transformSource: {\n            type: Function,\n            default: (svg) => svg,\n        },\n        keepDuringLoading: {\n            type: Boolean,\n            default: true,\n        },\n    },\n    data() {\n        return {\n            /** @type SVGElement */\n            svgElSource: null,\n        };\n    },\n    watch: {\n        src(newValue) {\n            // re-generate cached svg (`svgElSource`)\n            this.getSource(newValue);\n        },\n    },\n    mounted() {\n        // generate `svgElSource`\n        this.getSource(this.src);\n    },\n    methods: {\n        getSvgAttrs(svgEl) {\n            // copy attrs\n            let svgAttrs = {};\n            const attrs = svgEl.attributes;\n            if (!attrs) {\n                return svgAttrs;\n            }\n            for (let i = attrs.length - 1; i >= 0; i--) {\n                svgAttrs[attrs[i].name] = attrs[i].value;\n            }\n            return svgAttrs;\n        },\n        getSvgContent(svgEl) {\n            svgEl = svgEl.cloneNode(true);\n            svgEl = this.transformSource(svgEl);\n            if (this.title) {\n                setTitle(svgEl, this.title);\n            }\n\n            // copy inner html\n            return svgEl.innerHTML;\n        },\n        /**\n         * Get svgElSource\n         * @param {string} src\n         */\n        getSource(src) {\n            // fill cache by src with promise\n            if (!cache[src]) {\n                // download\n                cache[src] = this.download(src);\n            }\n            // notify svg is unloaded\n            if (this.svgElSource && cache[src].isPending() && !this.keepDuringLoading) {\n                this.svgElSource = null;\n                this.$emit('unloaded');\n            }\n\n            // inline svg when cached promise resolves\n            cache[src]\n                .then((svg) => {\n                    this.svgElSource = svg;\n                    // wait to render\n                    this.$nextTick(() => {\n                        // notify\n                        this.$emit('loaded', this.$el);\n                    });\n                })\n                .catch((err) => {\n                    // notify svg is unloaded\n                    if (this.svgElSource) {\n                        this.svgElSource = null;\n                        this.$emit('unloaded');\n                    }\n                    // remove cached rejected promise so next image can try load again\n                    delete cache[src];\n                    this.$emit('error', err);\n                });\n        },\n\n        /**\n         * Get the contents of the SVG\n         * @param {string} url\n         * @returns {Promise<Element>}\n         */\n        download(url) {\n            return makePromiseState(new Promise((resolve, reject) => {\n                const request = new XMLHttpRequest();\n                request.open('GET', url, true);\n\n                request.onload = () => {\n                    if (request.status >= 200 && request.status < 400) {\n                        try {\n                            // Setup a parser to convert the response to text/xml in order for it to be manipulated and changed\n                            const parser = new DOMParser();\n                            const result = parser.parseFromString(request.responseText, 'text/xml');\n                            let svgEl = result.getElementsByTagName('svg')[0];\n                            if (svgEl) {\n                                // svgEl = this.transformSource(svgEl);\n                                resolve(svgEl);\n                            } else {\n                                reject(new Error('Loaded file is not valid SVG\"'));\n                            }\n                        } catch (e) {\n                            reject(e);\n                        }\n                    } else {\n                        reject(new Error('Error loading SVG'));\n                    }\n                };\n\n                request.onerror = reject;\n                request.send();\n            }));\n        },\n    },\n};\n\n/**\n * Create or edit the <title> element of a SVG\n * @param {SVGElement} svg\n * @param {string} title\n */\nfunction setTitle(svg, title) {\n    const titleTags = svg.getElementsByTagName('title');\n    if (titleTags.length) { // overwrite existing title\n        titleTags[0].textContent = title;\n    } else { // create a title element if one doesn't already exist\n        const titleEl = document.createElementNS('http://www.w3.org/2000/svg', 'title');\n        titleEl.textContent = title;\n        svg.appendChild(titleEl);\n    }\n}\n\n/**\n * @typedef {Promise} PromiseWithState\n * @property {Function<boolean>} isPending\n */\n\n/**\n * This function allow you to modify a JS Promise by adding some status properties.\n * @param {Promise|PromiseWithState} promise\n * @return {PromiseWithState}\n */\nfunction makePromiseState(promise) {\n    // Don't modify any promise that has been already modified.\n    if (promise.isPending) return promise;\n\n    // Set initial state\n    let isPending = true;\n\n    // Observe the promise, saving the fulfillment in a closure scope.\n    let result = promise.then(\n        (v) => {\n            isPending = false;\n            return v;\n        },\n        (e) => {\n            isPending = false;\n            throw e;\n        },\n    );\n\n    result.isPending = function getIsPending() { return isPending; };\n    return result;\n}\n\nconst InlineSvgPlugin = {\n    install(Vue) {\n        Vue.component('inline-svg', InlineSvgComponent);\n    },\n};\n\nexport { InlineSvgComponent as default, InlineSvgComponent, InlineSvgPlugin };\n", "import d from \"./node_modules/vue-inline-svg/src/index.js\";export default d;\nexport * from \"./node_modules/vue-inline-svg/src/index.js\""],
  "mappings": "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",
  "names": []
}
